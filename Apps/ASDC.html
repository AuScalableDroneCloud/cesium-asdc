<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8" />
  <!-- Tell IE to use the latest, best version. -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
  <title>ASDC Cesium Platform</title>
  <script type="text/javascript" src="/cesium/Apps/Sandcastle/Sandcastle-header.js"></script>
  <script src="/cesium/Build/Cesium/Cesium.js"></script>
  <!-- <script src="../Build/CesiumUnminified/Cesium.js"></script> -->
  <style>
    @import url(/cesium/Apps/Sandcastle/templates/bucket.css);

    /* @import url(../Build/Cesium/Widgets/widgets.css); */
    /* html,
    body, */
    #cesiumContainer {
      width: 80%;
      position: absolute;
      left: 20%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #sidebar {
      width: 20%;
      position: absolute;
      left: 0%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #FFFBF5;
      color: black;
    }

    #sidebar-data-buttons {
      height: calc(100% - 34.6px);
      overflow: auto;
    }

    .sidebar-item {
      padding: 10px;
      border-bottom: 1px solid #EFE5D5;
    }

    .sidebar-upload-button {
      padding: 10px;
      border-top: 1px solid #EFE5D5;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 50%;
      top: 50%;
      width: 50%;
      height: 50%;
      transform: translate(-50%, -50%);

      overflow: auto;
      background-color: #FFFBF5;
    }

    .modal-header {
      color: black;
      padding: 2px 16px;
      width: calc(100% - 32px);
      border-bottom: 1px solid #EFE5D5;

    }

    .close {
      float: right;
      font-size: 28px;
      font-weight: bold;
      margin-top: 10px;
    }

    .close:hover,
    .close:focus {
      color: #EFE5D5;
      text-decoration: none;
      cursor: pointer;
    }

    .modal-content {
      height: calc(100% - 55.68px - 34.6px);
      overflow: auto;
    }

    .upload-inputs {
      color: black;
      left: 50%;
      position: relative;
      transform: translate(-50%, 0%);
      width: 75%;
      height: 100%;
      display: inline-grid;
      align-content: center;
    }

    .modal-upload-button {
      color: black;
      padding: 10px;
      border-top: 1px solid #EFE5D5;
      text-align: center;
    }

    .sidebar-item:hover,
    .sidebar-upload-button:hover,
    .modal-upload-button:hover {
      background: #5B8B51;
      cursor: pointer;
    }

    .add-file-button:hover {
      cursor: pointer
    }

    .input-line {
      flex-direction: row;
      width: 100%;
      display: inline-flex;
      justify-content: space-between;
      align-items: center;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>
  <div id="sidebar">
    <div id="sidebar-data-buttons"></div>
    <div class="sidebar-upload-button" onClick="openModal()">Upload</div>
  </div>
  <div class="modal" id="upload-modal">
    <div class="modal-header">
      <span class="close" onClick="closeModal()">&times;</span>
      <h2>Upload</h2>
    </div>
    <div class="modal-content">
      <div class="upload-inputs">
        <form name="upload-form" id="upload-form">
          <div class="input-line">
            <label for="name">Name:</label>
            <input type="text" name="name" required>
          </div>
          <br>
          <br>
          <div class="input-line">
            <input type="file" name="files[]" accept=".laz" required>
            <input type="date" name="dates[]" required>
          </div>
        </form>
        <br>
        <button class="add-file-button" onClick="addFileInput()">+</button>
      </div>
    </div>
    <div id="modal-upload-button" class="modal-upload-button" onClick="upload()">
      Upload
    </div>
  </div>

  <!-- <div id="toolbar"></div> -->

  <script>
    Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1NWZkNGFlZS1iNzVhLTRmNTAtOThmYi1kMTI1MjlmOTVlNjciLCJpZCI6NzIyNTQsImlhdCI6MTYzNTkwNDI4OX0.EXVvJZa8yaugMmQNkc9pjWfrjqeOpZ8Jg7_0Hdwnb1A";

    // var selectedDataset = "nue";
    // var selectedDataset = 1;
    var selectedDataset;

    var currentUrl = window.location.href;
    if (currentUrl[currentUrl.length - 1] === "/") currentUrl = currentUrl[currentUrl.length - 1];
    pathEnd = currentUrl.split('/')[currentUrl.split('/').length - 1];
    if (pathEnd.toLowerCase() != "asdc" && pathEnd.toLowerCase() != "asdc.html") {
      selectedDataset = pathEnd.toLowerCase();
      if(pathEnd.toLowerCase() === "nue") selectedDataset = 1;
      if(pathEnd.toLowerCase() === "vbir") selectedDataset = 2;
      if(pathEnd.toLowerCase() === "usln") selectedDataset = 3;
      if(pathEnd.toLowerCase() === "gillan_ecosphere") selectedDataset = 4;
      if(pathEnd.toLowerCase() === "dryandra_model") selectedDataset = 5;
      if(pathEnd.toLowerCase() === "dryandra_pointcloud") selectedDataset = 6;
      if(pathEnd.toLowerCase() === "graffiti_model") selectedDataset = 7;
      if(pathEnd.toLowerCase() === "graffiti_pointcloud") selectedDataset = 8;
    }

    const loadGeoJson = (dataset) => {

      var geoJsonPromise = Cesium.GeoJsonDataSource.load(dataset, {
        // clampToGround: true  //issues with picking polygons, using terrain sampling
      });

      // viewer.dataSources.add(geoJsonPromise);

      geoJsonPromise.then((dataSource) => {
        var entities = dataSource.entities.values;
        var samplePromises = [];

        dataSource.entities.values.map((entity) => {
          // dataSource.entities.values.slice(0,24).map((entity) => {
          var positions = entity.polygon.hierarchy.getValue().positions;
          var cartoPositions = [];
          positions.map(pos => {
            var carto = Cesium.Cartographic.fromCartesian(pos);
            cartoPositions.push(new Cesium.Cartographic(carto.longitude, carto.latitude));
          })

          samplePromises.push(Cesium.sampleTerrainMostDetailed(viewer.terrainProvider, cartoPositions).then((updatedPositions) => {
            var polygonEntity = viewer.entities.add({
              polygon:
              {
                hierarchy: new Cesium.PolygonHierarchy(Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(updatedPositions)),
                // hierarchy:new Cesium.CallbackProperty( () => {
                //   updatedPositions.map(cartoPoint=>{
                //   // var height = viewer.scene.sampleHeight(cartoPoint);
                //   var height = viewer.scene.globe.getHeight(cartoPoint);
                //   // console.log(height);
                //   if (height){
                //     cartoPoint.height=height;
                //   }
                // })
                //   return(new Cesium.PolygonHierarchy(Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(updatedPositions)));
                // },false),  //slow
                material: Cesium.Color.RED,
                perPositionHeight: true,
                // perPositionHeight: false, //picking issues
                arcType: Cesium.ArcType.GEODESIC
              }
            });
            polygonEntity.properties = entity.properties;
          }));
        })
        Promise.all(samplePromises).then(() => {
          delete (dataSource);
        })
      })

    }

    var highlightHeightPX = 27.2;
    var highlightColor = 'green';

    var viewer = new Cesium.Viewer('cesiumContainer', {
      terrainProvider: Cesium.createWorldTerrain(),
      // selectionIndicator: false
    });
    viewer.scene.screenSpaceCameraController.enableCollisionDetection = false;
    // viewer.scene.globe.depthTestAgainstTerrain = true;

    var tilesets = {};
    var entities = {};

    var assets;

    const loadAsset = (assets, assetID) => {
      var asset;

      assets.map(a => {
        if (a["id"] === parseInt(assetID)) {
          asset = a;
          return;
        }
      });
      if (!asset) return;
      selectedDataset = asset["id"];

      asset.data?.map((data) => {
        Object.keys(tilesets).map(tileset=>{
          Object.keys(tilesets[tileset]).map(date=>{
            tilesets[tileset][date].show=false;
          })
        })

        Object.keys(entities).map(entity=>{
          entities[entity].show=false;
        })

        if (data["type"] === "PointCloud") {
          if (!tilesets[selectedDataset]) tilesets[selectedDataset] = {};
          if (!tilesets[selectedDataset][new Date(data["date"])]) {
            tilesets[selectedDataset][new Date(data["date"])] = viewer.scene.primitives.add(new Cesium.Cesium3DTileset({
              url: data["url"],
              show: false
            }));
            if (data["position"]) {
              tilesets[selectedDataset][new Date(data["date"])].readyPromise.then(function (tileset) {
                var offset = Cesium.Cartographic.toCartesian(new Cesium.Cartographic.fromDegrees(data["position"]["lng"], data["position"]["lat"], data["position"]["height"]));
                var translation = Cesium.Cartesian3.subtract(offset, tileset.boundingSphere.center, new Cesium.Cartesian3());
                tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation);
              })
            }
          }
        } else if (data["type"] === "Model") {
          //TODO: multiple models for same location
          if (!entities[selectedDataset]) {
            var position = Cesium.Cartesian3.fromDegrees(
              data["position"]["lng"],
              data["position"]["lat"],
              data["position"]["height"]
            );
            var hpr = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(data["rotation"]["heading"]), Cesium.Math.toRadians(data["rotation"]["pitch"]), Cesium.Math.toRadians(data["rotation"]["roll"]));
            var orientation = Cesium.Transforms.headingPitchRollQuaternion(
              position,
              hpr
            );

            entities[selectedDataset] = viewer.entities.add({
              position: position,
              orientation: orientation,
              model: {
                uri: data["url"],
              }
            });
          } else {
            entities[selectedDataset].show=true;
          }
        } else if (data["type"] === "GeoJSON") {
          loadGeoJson(data.url);
        }
      })

      //TODO: move to index.json
      if (asset.type === "EPTPointCloud") {
        if (!tilesets[selectedDataset]) tilesets[selectedDataset] = {};
        tilesets[selectedDataset][new Date("2019-05-01")] = [];
        fetch('/cesium/Apps/may_2019_ils.txt')
          .then(response => response.text())
          .then(text => text.split("\n").map((line, index) => {
            if (index == 0) return;
            var path = line.split("C- ")[1];
            if (path) {
              tilesets[selectedDataset][new Date("2019-05-01")].push(viewer.scene.primitives.add(new Cesium.Cesium3DTileset({
                // url: `http://localhost:3000/tileset.json?ept=https://de.cyverse.org/anon-files${path}/ept.json&truncate`,
                url: `/ept/tileset.json?ept=https://de.cyverse.org/anon-files${path}/ept.json&truncate`,
                // url: `https://asdc.cloud.edu.au/ept/tileset.json?ept=https://de.cyverse.org/anon-files${path}/ept.json&truncate`,
                show: false
              })));

              viewer.flyTo(tilesets[selectedDataset][new Date("2019-05-01")][0]);
            }
          }))
        tilesets[selectedDataset][new Date("2019-09-01")] = [];
        fetch('/cesium/Apps/sept_2019_ils.txt')
          .then(response => response.text())
          .then(text => text.split("\n").map((line, index) => {
            if (index == 0) return;
            var path = line.split("C- ")[1];
            if (path) {
              tilesets[selectedDataset][new Date("2019-09-01")].push(viewer.scene.primitives.add(new Cesium.Cesium3DTileset({
                // url: `http://localhost:3000/tileset.json?ept=https://de.cyverse.org/anon-files${path}/ept.json&truncate`,
                url: `/ept/tileset.json?ept=https://de.cyverse.org/anon-files${path}/ept.json&truncate`,
                // url: `https://asdc.cloud.edu.au/ept/tileset.json?ept=https://de.cyverse.org/anon-files${path}/ept.json&truncate`,
                show: false
              })));
            }
          }))

        viewer.flyTo(tilesets[selectedDataset][Object.keys(tilesets[selectedDataset])[0]]);
        loadGeoJson("https://data.cyverse.org/dav-anon/iplant/commons/cyverse_curated/Gillan_Ecosphere_2021/leaflet_map/suas-footprints.geojson");
      }

      //TODO: dates for entities
      viewer.timeline._highlightRanges = [];
      if (tilesets[selectedDataset]) {
        Object.keys(tilesets[selectedDataset]).map(date => {
          viewer.timeline.addHighlightRange(highlightColor, highlightHeightPX).setRange(Cesium.JulianDate.fromDate(new Date(date)), Cesium.JulianDate.fromDate(new Date(new Date(date).getTime() + 86400000)));
        })


        var maxDate = new Date(Object.keys(tilesets[selectedDataset]).reduce(function (a, b) { return new Date(a).getTime() > new Date(b).getTime() ? a : b; }));
        var minDate = new Date(Object.keys(tilesets[selectedDataset]).reduce(function (a, b) { return new Date(a).getTime() < new Date(b).getTime() ? a : b; }));

        viewer.timeline.zoomTo(Cesium.JulianDate.fromDate(minDate), Cesium.JulianDate.fromDate(new Date(maxDate.getTime() + 86400000)));
        viewer.clock.currentTime = new Cesium.JulianDate.fromDate(minDate);

      };

      if (asset.data) {
        if (asset.data[0]["type"] === "PointCloud") {
          viewer.flyTo(tilesets[selectedDataset][Object.keys(tilesets[selectedDataset])[0]]);
        } else if (asset.data[0]["type"] === "Model") {
          viewer.flyTo(entities[selectedDataset]);
        }
      }
    }

    const setupSidebar = () => {
      fetch('https://appf-anu.s3.ap-southeast-2.amazonaws.com/Cesium/index.json', {cache: "no-store"})
        .then(response => response.text())
        .then(text => {
          var jsonResponse = JSON.parse(text);
          assets = jsonResponse["assets"];

          while (document.getElementById("sidebar-data-buttons").firstChild) {
            document.getElementById("sidebar-data-buttons").removeChild(document.getElementById("sidebar-data-buttons").firstChild);
          }
          assets.map(asset => {
            var assetDiv = document.createElement("div");
            
            assetDiv.innerHTML = asset["status"]==="processing" ? asset["name"] + " (processing)" : asset["name"];
            assetDiv.className = "sidebar-item";
            assetDiv.onclick = () => {
              window.history.pushState('', '', `/cesium/Apps/ASDC/${asset["id"]}`);
              loadAsset(assets, asset["id"]);
            };

            document.getElementById("sidebar-data-buttons").appendChild(assetDiv);
          })

          loadAsset(assets, selectedDataset);
        })
    }
    
    setupSidebar();

    viewer.clock.onTick.addEventListener((clock) => {
      currentTime = Cesium.JulianDate.toDate(clock.currentTime).getTime();

      if (tilesets[selectedDataset]) {
        var tilesetDates = Object.keys(tilesets[selectedDataset]);
        for (var i = 0; i < tilesetDates.length; i++) {
          if ((i === 0 || new Date(tilesetDates[i]).getTime() <= currentTime) && (i === tilesetDates.length - 1 || new Date(tilesetDates[i + 1]).getTime() >= currentTime)) {
            if (Array.isArray(tilesets[selectedDataset][tilesetDates[i]])) {
              tilesets[selectedDataset][tilesetDates[i]].map(tileset => { tileset.show = true; })
            } else {
              tilesets[selectedDataset][tilesetDates[i]].show = true;
            }
          } else {
            if (Array.isArray(tilesets[selectedDataset][tilesetDates[i]])) {
              tilesets[selectedDataset][tilesetDates[i]].map(tileset => { tileset.show = false; })
            } else {
              tilesets[selectedDataset][tilesetDates[i]].show = false;
            }
          }
        }
      }
    });

    var selectedEntity = new Cesium.Entity();
    var clickHandler = viewer.screenSpaceEventHandler.getInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
    viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {
      var pickedFeature = viewer.scene.drillPick(movement.position).filter(feature => {

        if (!(feature.primitive instanceof Cesium.Cesium3DTileset))
          return feature
      })[0];

      if (!Cesium.defined(pickedFeature)) {
        clickHandler(movement);
        return;
      }

      selectedEntity = pickedFeature.id;

      selectedEntity.description = '<table class="cesium-infoBox-defaultTable"><tbody>';
      for (var i = 0; i < selectedEntity.properties._propertyNames.length; i++) {
        selectedEntity.description += '<tr><th>' + selectedEntity.properties._propertyNames[i] + '</th><td>' + selectedEntity.properties[selectedEntity.properties._propertyNames[i]].getValue() + '</td></tr>';
      }
      selectedEntity.description += '</tbody></table>';
      viewer.selectedEntity = selectedEntity;

    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    
    const addFileInput = () => {
      var uploadForm = document.getElementById("upload-form");

      var lineDiv = document.createElement("div");
      lineDiv.className = "input-line";

      var fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.name = "files[]";
      fileInput.accept = ".laz";
      fileInput.required = true;

      lineDiv.appendChild(fileInput);

      var dateInput = document.createElement("input");
      dateInput.type = "date";
      dateInput.name = "dates[]";
      dateInput.required = true;

      lineDiv.appendChild(dateInput);

      var removeButton = document.createElement("input");
      removeButton.type = "button";
      removeButton.value = "x";
      removeButton.onclick = function () {
        lineDiv.remove();
      };
      lineDiv.appendChild(removeButton);

      uploadForm.appendChild(lineDiv);
    }

    const upload = () => {
      var xmlHttpRequest = new XMLHttpRequest();
      var form = document.forms.namedItem("upload-form");

      for (var i = 0; i < form.elements.length; i++) {
        if (form.elements[i].value === '' && form.elements[i].hasAttribute('required')) {
          alert('Please complete all required fields');
          return;
        }
      }

      var formData = new FormData(form);

      document.getElementById("modal-upload-button").innerHTML = "Uploading...";
      document.getElementById("modal-upload-button").style.pointerEvents = 'none';

      xmlHttpRequest.addEventListener('loadend', (progress) => {
        document.getElementById("modal-upload-button").innerHTML = "Upload";
        document.getElementById("modal-upload-button").style.pointerEvents = 'auto';
        console.log(progress);
      });

      // xmlHttpRequest.open("POST", 'http://localhost:8081/upload', true);
      xmlHttpRequest.open("POST", '/cesiumapi/upload', true);

      xmlHttpRequest.onreadystatechange = function () {
        if (xmlHttpRequest.readyState === 4) {
          console.log(xmlHttpRequest.response);
          setupSidebar();
          closeModal();
        }
      }

      xmlHttpRequest.send(formData);
    }

    var uploadModal = document.getElementById("upload-modal");

    const openModal = () => {
      uploadModal.style.display = "block";
    }

    const closeModal = () => {
      uploadModal.style.display = "none";
    }

  </script>
</body>

</html>